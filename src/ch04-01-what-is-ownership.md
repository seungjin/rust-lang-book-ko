## 소유권이란 무엇인가?

소유권은 러스트가 어떻게 메모리를 관리하는지에 대한 규칙의 모음이다. 모든 프로그램은 그 작동과정에서 컴퓨터의 메모리를 나름의 방식으로 관리한다. 어떤 언어들은 프로그램이 실행되면서 더 이상 필요하지 않는 메모리들을 스스로 꾸준히 찾아다니며 이를 정리해주는 가비지콜렉션이란것을  가지고 있고, 어떤 언어들은 프로그래머로 하여금 더이상 필요없는 메모리를 직접 정리하게 맞겨두는 방식을 취하기도 한다. 러스트의 경우 이 두가지가 아닌 새로운 방법을 이용하는데 이는 컴파일러를 통해 소유권에 대한 일련의 규칙을 적용해보고 이 규칙에 위배되는 경우에는 컴파일을 거부함으로서 해당 경우를 원천적으로 제거하는 것이다. 만약 컴파일러가 메모리 소유권에 대한 규칙 위반을 발견하게 되면 컴파일러는 해당 코드에 대한 컴파일을 거부한다. 이러한 소유권에 대한 규칙위반을 확인하는 과정은 컴파일시에 벌어지는 행위로 프로그램이 성공적으로 컴파일 된 이후 프로그램이 본 실행되는 과정에선 이 소유권 확인에 따르는 성능저하가  일어나지 않는 장점을 지니게 된다.

많은 프로그래머들에게 소유권은 매우 생소한 개념일것이고 아마 적응하는데 어느정도의 시간이 필요할것이다. 하지만 러스트와 러스트의 소유권에 대해서 점점 익숙해질수록 이 소유권이라는 것이 메모리관리의 문제로부터 여러분을 보호해 줄것이며 어느순간 효율적으로 메모리를 관리하고 있는 여러분들을 보게 될것이다. 

소유권에 대한 충분한 이해가 형성되었을쯤엔 여러분들에게 러스트가 어떻게 독보적인 방식으로 러스트만의 특별함을 구축하였는지에 대한 탄탄한 기반이 형성되어 있을 것이다. 이번장에서는 문자열(String)이라는 매우 일반적인 데이터 스트럭쳐를 가지고 어떻게 소유권이 작동하는지 예제와 함게 살펴보도록 하겠다.

<!-- PROD: START BOX -->

> ### 스택과 힙
>
> 모든 프로그램언어가 프로그램 과정에서 스택과 힙에 대해 꾸준히 염두하며 프로그램을 하기를 요구하지는 않는다. 하지만 러스트와 같은 시스템 언어의 경우엔 해당 메모리가 스택에 존재하느냐 힙에 존재하느냐에 따라서 프로그램 언어가 어떻게 이를 처리하는지가 다르며 따라서 스택이냐 힙이냐에 따라서 프로그래머가 프로그램을 짜는 방식이 달라지게 된다. 이번챕터의 뒷부분에서 스택과 힙의 관계가 소유권을 설명하기 위해서 나오게 되므로 지금은 그 뒷부분을 위한 사전지식정도로 간단하게 설명하고 넘어가도록 하겠다. 
>
> 스택과 힙은 둘다 코드가 실행될때 코드에 할당되는 메모리의 부분을 지칭하는 말이다. 다만 이 둘은 서로 다른 구조적 차이가 있다. 스택은 들어오는 값들을 들어오는 순서대로 쌓아서 저장한다. 그리고 호출을 받을경우에는 들어오는 대로 쌓은 순서의 반대로, 즉 최근에 들어온 값의 순서로 내보내게된다. 이를 LIFO(Last In, First Out)라 부르는데 음식점에서 쌓여있는 접시들을 생각하면 될것이다. 설겆이를 마친 접시가 새로 추가되면 이미 쌓여진 접시의 가장 위애 이 접시를 추가하고 새로운 접시가 고객에게 서비스 되기 위해 필요할경우 이미 쌓여진 접시의 가장 윗부분에서 접시를 꺼내서 내어주는 것이다. 중간에나 가장 밑에서 접시를 빼려고 한다면 자칫잘못 접시더미에 깔리는 위험을 감수해야 할수 도 있을것이다. 데이터를 추가하는 것을 스텍으로 밀어넣는다(push)라고 부르고 데이터를 스택에서 꺼내는것을 영어로 팝(pop)이라고 부른다. 스택을 넣는다는 것을 영어 표현으로 Pushing on the stack(스택으로 밀어넣다), 스택에서 꺼낸다는 것을 영어로 Poping off the stack(스택에서 꺼내다)이 라고 쓴다. 스택에 저장되는 데이터들은 전부 그 크기가 미리 정해져있는 데이터들이다. 컴파일시에 그 크기가 정해지지 않았거나, 그 크기가 변할수 있는 데이터들은 힙의 영역에 저장되게 된다.    
>
> 힙은 스택에 비하면 어지럽게 정리된 찬장같다고 할수있다: 데이터를 힙의 영역에 넣기위해 일단 일정부분의 공간을 확보를 필요로 하며 일단 그 공간을 시스템에 요청하게 된다. 이떄 메모리 할당자(allocator)는 요청받은 힙이 충분히 들어갈만한 공간을 찾아 그 공간을 확보함과 동시에 해당 공간에 대해 이용중(점유중)이라는 표식을 남기면서 해당영역의 위치를 나타내는 *포인터*를 반환한다. 이러한 일련의 행위를 *힙 공간을 할당(allocating on the heap)*이라고 부르며 때때로 *할당(Allocating)*이라고 줄여 말하기도 한다. 반면 스택에 값을 밀어넣는 과정은 힙과와 다르게 할당이라 부르지는 않는다. 그냥 스택에 데이터를 밀어 넣는것이라고 표현한다. 힙 메모리공간을 지칭하는 포인터 자체는 그 크기가 정해져있기때문에 우리는 그 포인터를 스택에 저장할수 있다. 하지만 실제 데이터를 알기위해서는 포인터만으로 그 값을 알수 있는게 아니라 그 포인터가 지칭하는 곳으로 따라가야 실제 값을 구해올수 있다. 레스토랑에서 좌석을 안내받는 경우를 생각해보자. 일단 레스토랑에 들어가면 여러분은 일행이 몇명인지를 레스토랑 직원에게 알려준다. 그러면 레스토랑의 직원은 해당인원에 맞는 빈테이블을 확인한후 여러분과 일행을 그 테이블로 안내한다. 만약 여러분의 일행중 한명이 늦게 도착해서 여러분을 찾는다면 뒤에 도착한사람은 점원에게 여러분들이 어디에 앉아있는지 먼저 물어본후 여러분의 자리로 찾아가 합류 할수 있게 되는 것이다.
>
> 스택에 데이터를 밀어 넣는 경우라면 힙의 경우처럼 할당자에게 해당위치를 물어볼필요가 없기때문에 힙에 데이터의 영역을 할당받는것보다 상당히 빠르게 데이터를 저장할 수 있다; 스택이 데이터를 밀어 넣는 곳은 항상 그 스택의 가장 윗부분이 된다. 이와는 반대로 힙에 공간을 할당받는 행위는 더 많은 절차를 요구한다. 일단 할당자는 데이터가 들어갈 충분한 공간을 찾아서 확보해야 하고 후에 다른 데이터들이 들어올때를 대비해서 그 공간이 이미 점유되었다는 것을 기록해두어야 한다.
>
> 힙에 있는 데이터에 접근하는 것은 스택에 비해서 느릴수 밖에 없다. 일단 포인터를 가지고 해당 데이터의 위치를 알아내야 하는 절차를 먼저 거쳐야 하기 때문이다. 현대의 프로세서들은 메모리들 사이에서 이리저리 해당위치를 찾아내는 행위가 적으면 적을수록 더 빠른 성능을 보여준다. 붐비는 레스토랑에서 여러 테이블로부터 주문을 받는 레스토랑 직원의 경우를 생각해보자. 한테이블에서 해당 테이블의 주문을 한번에 다 받고 그리고 다음 테이블로 가서 그 테이블의 주문을 그렇게 순차적으로 받아가는것이 효율적일것이다. 테이블 A에서 주문을 하나 받고 바로 테이블 B로 가서 또 하나의 주문을 받은후 다시 테이블 A로 돌아와 주문을 마져 받고 그렇게 주문을 하나씩 각각의 테이블에서 받는다면 어떨지 생각해보자. 여러분의 음식은 매우 느리게 나올것이 아닌가. 같은 맥락에서 프로세서는 만약 처리해야 할 데이터들이 한곳에 일렬로 붙어서(마치 스택처럼) 나열되어있는 경우에 처리해야 할 데이터가 여기저기 흩어져 산재해 있는 경우보다 훨신 작업을 잘 수월히 할수 있을것이다. 힙에 많은 양의 데이터를 할당하는 경우 또한 시간이 꽤 걸리게 된다.
>
> 당신의 코드가 함수를 호출할때 함수의 인자값(힙에 위치한 데이터를 가르키는 포인터까지도 포함해)은 함수로 전달되게 된다. 그리고 함수의 지역변수들이 스택으로 밀어넣어진다. 그리고 함수가 끝날때 그 값들은 스택으로부터 꺼내어 지게 된다.
>
> 코드의 어떤 부분이 힙상의 어떤 데이터를 이용하고 있는지를 기록하고 힙에 위치한 데이터의 중복을 최소화 하며, 힙에서 더이상 이용되지 않는 데이터를 정리함으로서 힙의 데이터 공간이 모자르지 않게 관리하는 일련의 작업이 바로  소유권이 해결하는 분야이다. 일단 소유권이란것을 이해하고 난후 여러분은 더이상 힙과 스택에 대해서 복잡하게 생각해야 할경우가 줄게 될것이다. 소유권이라는것이 바로 힙데이터를 관리한다는 것을 이해하는것은 소유권이 어떻게 작동하고 소유권이란 무엇인지를 이해하는데 큰 도움이 될것이다.
>
> <!-- PROD: END BOX -->


### 소유권의 규칙

먼저, 소유권 규칙을 알아보자. 다음의 소유권의 규칙들을 소유권이 설명하는 내내 명심하기로 하자.

> * 러스트의 각각의 값은 해당값의 *오너*(*owner*)라고 불리우는 변수를 갖고 있다.
> * 한번에 딱 하나의 오너만 존재할 수 있다.
>
> * 오너가 스코프 밖으로 벗어나는 때, 값은 버려진다(dropped).


### 변수의 스코프

앞에서 러스트의 기본 문법을 살펴보았기에 더이상 코드의 예제에  `fn main() {` 를 붙이지는 않겠다. 만약 코드를 실제로 따라한다면 `main` 함수에 직접 예제들을 넣어 실행하도록 하기 바란다. `main()`함수를 포함한 보일러플레이트 코드를 이용하는 경우보다 이를 생략하는 것이 코드가 훨신 더 간단하고 읽기 좋을 것이며 덕분에 우리가 이야기 하는 부분에 더 집중하는데 도움이 될것이다.

소유권에 대한 첫 예제로서, 변수들의 스코프를 살펴보자. 스코프란 프로그램 내에서 어떤 아이템이 유효 하고 어떤 아이템은 더이상 유효하지 않는가에 대한 범위이다. 다음과 같은 변수가 있다고 해보자:

```rust
let s = "hello";
```

변수 `s`는 스트링 문자열을 나타내는데, 스트링 문자열의 값은 코드안에서 하드코딩되어 있다. 변수는 선언된 시점부터 현재의 스코프가 끝나는 시점까지 유효하다. 다음의 Listing 4-1은 변수 `s`의 유효한 범위를 커맨트로 나타낸 코드이다

```rust
{                      // 선언전 s는 유효하지 않다
    let s = "hello";   // 이 지점부터 s는 유효

    // s를 이용하여 어떤 처리를 한다
}                      // 현재 스코프의 끝. s는 더이상 유효하지 않음
```

<span class="caption">Listing 4-1: 변수와 유효한 스코프</span>

여기에서 중요한 두가지를 보면:

* 일단 `s`가 z스코프안으로 들어오면 `s`는 유효하다.

* `s`의 유효성은 스코프 `밖으로 벗어나기` 전까지는 유효하다.

여기까지는 다른 프로그램 언어에서 이야기하는 스코프와 변수 그리고 그 유효성의 관계와 비슷하다. 이제부터 `string` 타입을 소개함으로서 이에 덧붙여서 좀더 깊게 이야기를 해보기로 하자. 

### `String` 타입

소유권 규칙을 설명하기 위해선, 3장 "Data Types"에서 다룬 바 있는 타입들보다 더 복잡한 데이터 타입이 필요하다. 이전에 이야기한 모든 데이터 타입들은  모두 그 크기가 이미 정의되어 있고 스택에 저장되어있다가 스코프를 벗어나면서 스택에서 부터 꺼내지는 형태들이다. 이제 우리는 힙에 저장되는 데이터 타입을 살펴볼 것이며 Rust가 z어떻게 그 힙에 저장되는 데이터들을 처리하는 지를 알아볼것이다. 이를 위해 `String`타입은 더할나위 없이 좋은 예제이다.

우리는 소유권에 촛점을 맞추어 'String'의 일부 기능에 대해서 집중적으로 이야기 할것이다. 이는 표준라이브러리나 여러분이 후에 만들게 될 더 복잡한 데이터 타입에도 동일하게 적용될 이야기들이다. `String` 자체에 대한 일반적인 이야기는 8장에서 더 깊게 다루기로 하겠다. 

프로그램 안에서 하드코딩된 상태로 있는 스트링 리터럴(문자열)의 경우, 그 이용 자체는 매우 편리하지만 모든 상황에 스트링 리터럴(문자열)을 이용할수 있는 건 아니다. 일례로 스트링 리터럴(문자열)은 이뮤터블(immutable) 즉 한번 정해지면 변경이 불가능하게 된다. 또한 모든 문자값이 코드를 작성하는 시기에 이미다 정해져있는 것은 아니다. 사용자로 부터 값을 받아서 그 값을 저장하는 경우에는 어떻게 스트링 리터럴(문자열)을 지정할것인가? 사용자로부터 값을 받기전까지는 그 값을 알수가 없지 않은가? 이런 경우에 대해서 러스트는 `string`이라는 타입을 제공하고 있다. 이 타입은 힙에 공간을 할당받아 데이터를 저장하는 방식을 취하고 있다. 따라서 컴파일 시점에서 해당하는 텍스트 데이터를 몰라도 일단 지정이 가능하다. 다음과 같이 `from` 함수를 이용하여 `String` 타입의 문자열을 생성할 수 있다. 

```rust
let s = String::from("hello");
```

더블 콜론 `::` 은 `string_from`과 같은 이름을 쓰기 보다는 `String` 타입 아래의`from` 함수를 특정지을 수 있도록 해주는 네임스페이스 연산자이다. 5장의 ["메소드 문법"][method-syntax]<!-- ignore --> 부분에서 이러한 문법에 대헤 더 자세히 다룰 것이고, 모듈과 네임스페이스에 대해서는 7장의 ["Paths for Referring to an Item in the Module Tree"][paths-module-tree]<!-- ignore -->에서 더 다루도록 하겠다.

이제 이렇게 생성된 스트링 문자열은 해당 데이터가 변할수 있는(muttable) 상태가 된다.

```rust
let mut s = String::from("hello");

s.push_str(", world!"); // push_str()은 인자로 받은 스트링 리터럴을  기존 스트링에 붙이는 역활을 한다.

println!("{}", s); //`hello, world!`가&nbsp;출력된다.
```

스트링 리터럴을 쓰는것과 스트링 타입을 쓰는 경우에는 어떤 차이가 있는 것일가? 왜 `String`타입은 뮤터블(muttable)이고 스트링문자열은 임뮤터블(immutable)일까? 그 차이는 이 두타입이 각각 다르게 메모리를 처리하고 있음에 기인한다.

### 메모리와 할당

스트링 리터럴 즉 문자열의 경우, 컴파일시점에 이미 어떤 데이터가 담길것일지 정해져있다. 따라서 텍스트가 바로 직접 코드에 하드코딩 되며 최종 실행까지 바로 되는 것이다. 이와 같은 이유로 스트링 리터럴, 문자열은 매우 빠르고 뛰어난 처리 효율성을 보여준다. 하지만 이는 스트링 리터럴, 즉 문자열은 이미 정해진 값이며 불변하다는 전재로 부터 받는 장점이다. 불행히도 컴파일시점에 그 데이터의 크기가 확정되지도 또한 프로그램이 실행되는 과정에서 그 데이터가 변하는 텍스트들의 조각이 바이너리 파일에 포함될수는 없다. 

내용이 변경가능하고 언제든지 그 크기가 늘어날수 있는 텍스트를 처리하기 위해 `String` 타입은 컴파일시에 힙상의 일정부분 메모리를 할당받아 잡고 있는다. 이는 다음을 의미하는데:

1. 런타임시에 메모리 관리자에게 메모리를 요청한다.
2. `String`이 더 이상 필요없어졌을시에 메모리 관리자에게 메모리를 반납한다.

첫번째 요구 사항은 프로그래머의 몫이다. 다른 여타의 언어들과 마찬가지로 프로그래머가  `String::from`를 호출하게 되면 이때 필요한 만큼의 메모리가 요청된다.

두번째는 *가비지 콜렉터 (GC) *를 가지고 있는 언어들의 경우 GC가 z지속적으로 메모리들을 추적관찰하며 해당 메모리가 더 이상 필요없을시에 해당 메모리를 청소하게 된다. 따라서 개발자는 딱히 해당 부분에 대해 신경을 쓸필요가 없다. CG를 제공하지 않는 대부분의 언어의 경우는 언제 메모리가 더이상 이용하지 않게 되는가를 결정하고 해당 메모리를 반환하라고 명령하는것이 프로그래머의 몫이 된다. 지난 경험으로 미루어보아 언제 메모리가 필요하지 않게 되는지를 결정하고 반환을 요청하는 일자체는 매우 어려운 프로그래밍의 문제이며 이를 제대로 잘 하는것은 매우 힘든 일이라는것이 일반적이다. 만약 메모리를 반환하는 것을 잊게 되면 메모리를 낭비하는 결과를 초래하게 되면 너무 일찍 메모리의 반환을 요구 한다면 필요한 변수의 값이 유효하지 않는 결과를 초래하게 된다. 또한 두번 메모리의 반환을 요구하게 되는 경우에도 버그로 이어지는 결과를 가져온다. 한번의 메모리 *할당(allocate)* 당 한번의 *반환(free)*가 z쌍을 이루어 행해져야 하는 것이다.

러스트의 경우 다른 방법을 취한다: 메모리의 소유권을 취하는 변수가 스쿱에서 사라지면 즉 효용성이 사라지게 되는 순간 해당 메모리를 반환하게 된다. 여기 스트링 리터럴 대신 `String` 타입을 사용한 Listing 4-1의 스코프 예제가 있다:

```rust
{
    let s = String::from("hello"); // 이 지점부터 s는 유효

    // s를 이용하여 어떤 처리를 한다
}                                  // 현재 스코프의 끝
                                   // s는 더이상 유효하지 않음
```

코드를 보면 `s`가 z범위/스코프를 벗어나는 순간 다른말로 하면 더이상 유효하지 않게 되는순간 자연스럽게 해당 메모리를 반환한다. Rust는  `drop`이라 불리는 특별한 함수를 변수의 유효성이 사라지는 순간 호출하게 되는데 이 `drop`이란 함수는 `String`타입을 프로그램될때 메모리의 반환하기 위해 넣은 것이다. 러스트는 이 `drop` 함수를 `} (증괄호)`가 z닫힐때 자동으로 호출하게 되어있다. 

> 노트: C++에서는 이렇게 아이템의 수명주기의 끝나는 시점에 자원을 해제하는 패턴을 종종 *자원 습득이 곧 초기화* (*Resource Acquisition Is Initialization, RAII*) 라고 부르는데, 이미 여러분이 RAII 패턴에 익숙해져있다면 러스트에서의 `drop` 함수또한 익숙하게 느껴질 것이다..

이 패턴은 러스트 코드에 깊은 영향을 주었다. 지금은 그냥 단순해 보이는 규칙같아 보일수도 있으나 여러 다양한 변수들이 힙상에서 할당받은 데이터들을 이용하는 과정에서 코드들의 예기치 않는 복잡한 상황이 발생하게 된다. 이제 그런 경우들에 대해 탐험해보기로 하자. 

#### 변수와 데이터가 상호작용하는 방법: 이동(move)

러스트에선 하나의 데이터에 대해서 여러 개의 변수들이 여러가지 방법으로 상호작용 할수 있다. Listing 4-2에서 정수형태의 데이터를 가진 예제를 한번 보기로 하자:

```rust
let x = 5;
let y = x;
```

<span class="caption">Listing 4-2: 변수 `x`의 정수값을 `y`에 대입하기</span>

다른 언어들에서의 경험을 토대로 어떤 일이 벌어지는지 추측해 보면:
“정수값 `5`를 `x`에 대입한후; `x`의 값의 복사본을 만들어 `y`에 대입한다.”  이제
`x`와 `y` 두 개의 변수가 있고 둘 다 `5`라는 같은 값을 가지고 있다.

<< WORKING CONT'ed >>

 정수값이 결정되어 있는
고정된 크기의 단순한 값이고, `5`라는 값들이 스택에 푸쉬되기 때문에, 실제로도 이렇게
됩니다.

이제 `String` 버전을 봅시다:

```rust
let s1 = String::from("hello");
let s2 = s1;
```

이 코드는 이전의 코드와 매우 유사해 보여서, 동작하는 방식도 동일할 것이라고 가정할지도
모르겠습니다: 즉, 두번째 줄이 `s1`의 복사본을 만들어서 `s2`에 묶어놓는 식으로 말이죠.
그렇지만 이는 실제 동작과 다른 생각입니다.

좀 더 완전히 설명하기 위해, `String`이 Figure 4-3에서와 같이 생겼다는 것을 주목합시다.
`String`은 그림의 왼쪽과 같이 세 개의 부분으로 이루어져 있습니다: 문자열의 내용물을
담고 있는 메모리의 포인터, 길이, 그리고 용량입니다. 이 데이터의 그룹은 스택에 저장됩니다.
내용물을 담은 오른쪽의 것은 힙 메모리에 있습니다.

<img alt="String in memory" src="img/trpl04-01.svg" class="center" style="width: 50%;" />

<span class="caption">Figure 4-3: `s1` 변수에 `"hello"`값이 저장된 `String`의
메모리 구조</span>

길이값은 바이트 단위로 `String`의 내용물이 얼마나 많은 메모리를 현재 사용하고 있는지를
말합니다. 용량값은 바이트 단위로 `String`이 운영체제로부터 얼마나 많은 양의 메모리를
할당 받았는지를 말합니다. 길이와 용량의 차이는 중요합니다만, 이번 내용에서는 아닙니다.
그러니까 현재로서는 용량값을 무시하셔도 좋겠습니다.

`s2`에 `s1`을 대입하면, `String` 데이터가 복사되는데, 이는 스택에 있는 포인터, 길이값,
그리고 용량값이 복사된다는 의미입니다. 포인터가 가리키고 있는 힙 메모리 상의 데이터는
복사되지 않습니다. 달리 말하면, 메모리 내의 데이터 구조는 Figure 4-4와 같이 됩니다.

<img alt="s1 and s2 pointing to the same value" src="img/trpl04-02.svg" class="center" style="width: 50%;" />

<span class="caption">Figure 4-4: `s1`의 포인터, 길이값, 용량값이 복사된 `s2` 변수의
메모리 구조</span>

메모리 구조는 Figure 4-5와 같지 *않는데*, 이 그림은 러스트가 힙 메모리 상의 데이터까지도
복사한다면 벌어질 일입니다. 만일 러스트가 이렇게 동작한다면, 힙 안의 데이터가 클 경우
`s2 = s1` 연산은 런타임 상에서 매우 느려질 가능성이 있습니다.

<img alt="s1 and s2 to two places" src="img/trpl04-03.svg" class="center" style="width: 50%;" />

<span class="caption">Figure 4-5: 러스트가 힙 데이터까지 복사하게 될 경우 `s2 = s1`가
만들 또다른 가능성</span>

앞서 우리는 변수가 스코프 밖으로 벗어날 때, 러스트는 자동적으로 `drop`함수를 호출하여
해당 변수가 사용하는 힙 메모리를 제거한다고 했습니다. 하지만 Figure 4-4에서는 두 데이터
포인터가 모두 같은 곳을 가리키고 있는 것이 보입니다. 이는 곧 문제가 됩니다: `s2`와 `s1`이
스코프 밖으로 벗어나게 되면, 둘 다 같은 메모리를 해제하려 할 것입니다. 이는 *두번 해제*
(*double free*) 오류라고 알려져 있으며 이전에 언급한 바 있는 메모리 안정성 버그들 중
하나입니다. 메모리를 두번 해제하는 것은 메모리 손상(memory corruption)의 원인이 되는데,
이는 보안 취약성 문제를 일으킬 가능성이 있습니다.

메모리 안정성을 보장하기 위해서, 러스트에서는 이런 경우 어떤 일이 일어나는지 한가지 더
디테일이 있습니다. 할당된 메모리를 복사하는 것을 시도하는 대신, 러스트에서는 `s1`이
더이상 유효하지 않다고 간주하고, 그러므로 러스트는 `s1`가 스코프 밖으로 벗어났을 때
이무것도 해제할 필요가 없어집니다. `s1`을 `s2`가 만들어진 후에 사용하려고 할때 어떤
일이 벌어지는지 확인해 봅시다:

```rust,ignore
let s1 = String::from("hello");
let s2 = s1;

println!("{}, world!", s1);
```

여러분은 아래와 같은 에러 메세지를 보게 될텐데, 그 이유는 러스트가 여러분으로부터
유효하지 않은 참조자를 사용하는 것을 막기 때문입니다:

```text
error[E0382]: use of moved value: `s1`
 --> src/main.rs:4:27
  |
3 |     let s2 = s1;
  |         -- value moved here
4 |     println!("{}, world!", s1);
  |                            ^^ value used here after move
  |
  = note: move occurs because `s1` has type `std::string::String`,
which does not implement the `Copy` trait
```

만일 여러분이 다른 언어로 프로그래밍 하는 동안 “얕은 복사(shallow copy)”와 “깊은
복사(deep copy)”라는 용어를 들어보셨다면, 데이터의 복사 없이 포인터와 길이값 및
용량값만 복사한다는 개념이 얕은 복사와 비슷하게 들릴지도 모르겠습니다. 하지만
러스트는 첫번째 변수를 무효화 시키기도 하기 때문에, 이를 얕은 복사라고 부르는 대신
*이동*(*move*)이라 말합니다. 여기서 우리는 `s1`이 `s2`로 *이동되었다*라고 말하는
식으로 위 코드를 읽을 것입니다. 그러므로 실제로 일어낸 일은 Figure 4-6과 같습니다.

<img alt="s1 moved to s2" src="img/trpl04-04.svg" class="center" style="width: 50%;" />

<span class="caption">Figure 4-6: `s1`이 무효화된 후의 메모리 구조</span>

이것이 우리 문제를 해결해줍니다! 오직 `s2`만 유효한 상황에서, 스코프 밖으로 벗어나면
혼자 메모리를 해제할 것이고, 일이 잘 처리되겠습니다.

여기에 더해서, 이러한 경우가 함축하는 디자인 선택이 있습니다: 러스트는 결코 자동적으로
여러분의 데이터에 대한 “깊은” 복사본을 만들지 않을 것입니다. 그러므로, 어떠한
*자동적인* 복사라도 런타임 실행 과정에서 효율적일 것이라 가정할 수 있습니다.

#### 변수와 데이터가 상호작용하는 방법: 클론

만일 `String`의 스택 데이터 만이 아니라, 힙 데이터를 깊이 복사하기를 정말 원한다면,
`clone`이라 불리우는 공용 메소드를 사용할 수 있습니다. 이 메소드 문법에 대해서는
5장에서 다루게 될 것입니다만, 이 메소드가 많은 프로그래밍 언어들 사이에서 흔한
특성이기 때문에, 여려분은 아마도 전에 이런 것들을 본적이 있을지도 모르겠습니다.

`clone` 메소드가 동작하는 예제를 보겠습니다:

```rust
let s1 = String::from("hello");
let s2 = s1.clone();

println!("s1 = {}, s2 = {}", s1, s2);
```

이 코드는 잘 동작하고 Figure 4-5가 나타내는, 즉 힙 데이터가 *정말로* 복사되는 동작을
여러분이 명시적으로 만들어낼 수 있는 방법입니다. 

`clone`을 호출하는 부분을 보면, 어떤 비용이 많이 들어갈지도 모르는 코드가 실행되는
중이란 것을 알 수 있게 됩니다. 이는 무언가 다른 동작이 수행되는 것을 알려주는 시각적인
지시자입니다.

#### 스택에만 있는 데이터: 복사

우리가 아직 다루지 않은 또다른 부분이 있습니다. 아래 코드는 앞서 Listing 4-2에서
본 정수값을 이용하는 코드로, 잘 동작하며 유효합니다:

```rust
let x = 5;
let y = x;

println!("x = {}, y = {}", x, y);
```

하지만 이 코드는 우리가 방금 배운 것과 대립되는 것처럼 보입니다: `clone`을 호출하지
않았지만, `x`도 유효하며 `y`로 이동하지도 않았지요.

그 이유는 정수형과 같이 컴파일 타임에 결정되어 있는 크기의 타입은 스택에 모두 저장되기
때문에, 실제 값의 복사본이 빠르게 만들어질 수 있습니다. 이는 변수 `y`가 생성된 후에
`x`가 더 이상 유효하지 않도록 해야할 이유가 없다는 뜻입니다. 바꿔 말하면, 여기서는
깊은 복사와 얕은 복사 간의 차이가 없다는 것으로, `clone`을 호출하는 것이 보통의
얕은 복사와 아무런 차이점이 없어 우리는 이를 그냥 버릴 수 있다는 것입니다.

러스트는 정수형과 같이 스택에 저장할 수 있는 타입에 대해 달수 있는 `Copy` 트레잇이라고
불리우는 특별한 어노테이션(annotation)을 가지고 있습니다 (트레잇에 관해서는 10장에서
더 자세히 보겠습니다). 만일 어떤 타입이 `Copy` 트레잇을 갖고 있다면, 대입 과정 후에도
예전 변수를 계속 사용할 수 있습니다. 러스트는 만일 그 타입 혹은 그 타입이 가지고 있는
부분 중에서 `Drop` 트레잇을 구현한 것이 있다면 `Copy` 트레잇을 어노테이션 할 수 없게끔
합니다. 만일 어떤 타입이 스코프 밖으로 벗어났을 때 어떤 특수한 동작을 필요로 하고 우리가
그 타입에 대해 `Copy` 어노테이션을 추가한다면, 컴파일 타임 오류를 보게 됩니다. `Copy`
어노테이션을 여러분의 타입에 어떤 식으로 추가하는지 알고 싶다면, 부록 C의 파생 가능한
트레잇(Derivable Traits)을 보세요.

그래서 어떤 타입이 `Copy`가 될까요? 여러분은 주어진 타입에 대해 확신을 하기 위해 문서를
확인할 수도 있겠지만, 일반적인 규칙으로서 단순한 스칼라 값들의 묶음은 `Copy`가
가능하고, 할당이 필요하거나 어떤 자원의 형태인 경우 `Copy`를 사용할 수 없습니다.
`Copy`가 가능한 몇가지 타입을 나열해 보겠습니다:

* `u32`와 같은 모든 정수형 타입들
* `true`와 `false`값을 갖는 부울린 타입 `bool`
* `f64`와 같은 모든 부동 소수점 타입들
* `Copy`가 가능한 타입만으로 구성된 튜플들. `(i32, i32)`는 `Copy`가 되지만,
  `(i32, String)`은 안됩니다.

### 소유권과 함수

함수에게 값을 넘기는 의미론(semantics)은 값을 변수에 대입하는 것과 유사합니다.
함수에게 변수를 넘기는 것은 대입과 마찬가지로 이동하거나 복사될 것입니다. Listing
4-7은 변수가 스코프 안으로 들어갔다 밖으로 벗어나는 것을 주석과 함께 보여주는 예입니다:

<span class="filename">Filename: src/main.rs</span>

```rust
fn main() {
    let s = String::from("hello");  // s가 스코프 안으로 들어왔습니다.

    takes_ownership(s);             // s의 값이 함수 안으로 이동했습니다...
                                    // ... 그리고 이제 더이상 유효하지 않습니다.
    let x = 5;                      // x가 스코프 안으로 들어왔습니다.

    makes_copy(x);                  // x가 함수 안으로 이동했습니다만,
                                    // i32는 Copy가 되므로, x를 이후에 계속
                                    // 사용해도 됩니다.

} // 여기서 x는 스코프 밖으로 나가고, s도 그 후 나갑니다. 하지만 s는 이미 이동되었으므로,
  // 별다른 일이 발생하지 않습니다.

fn takes_ownership(some_string: String) { // some_string이 스코프 안으로 들어왔습니다.
    println!("{}", some_string);
} // 여기서 some_string이 스코프 밖으로 벗어났고 `drop`이 호출됩니다. 메모리는
  // 해제되었습니다.

fn makes_copy(some_integer: i32) { // some_integer이 스코프 안으로 들어왔습니다.
    println!("{}", some_integer);
} // 여기서 some_integer가 스코프 밖으로 벗어났습니다. 별다른 일은 발생하지 않습니다.
```

<span class="caption">Listing 4-7: 소유권과 스코프에 대한 설명이 주석으로 달린 함수들</span>

만일 우리가 `s`를 `takes_ownership` 함수를 호출한 이후에 사용하려 한다면, 러스트는
컴파일 타임 오류를 낼 것입니다. 이러한 정적 확인은 여러 실수들을 방지해 줍니다.
이후에 변수들을 사용할 수 있는지, 그리고 그러한 것을 소유권 규칙이 막아주는지를
확인해보려면 `main` 안에 `s`와 `x`에 관한 코드를 추가해보세요.

### 반환 값과 스코프

값의 반환 또한 소유권을 이동시킵니다. Listing 4-7과 비슷한 주석이 달린 예제를 하나
봅시다:

<span class="filename">Filename: src/main.rs</span>

```rust
fn main() {
    let s1 = gives_ownership();         // gives_ownership은 반환값을 s1에게
                                        // 이동시킵니다.

    let s2 = String::from("hello");     // s2가 스코프 안에 들어왔습니다.

    let s3 = takes_and_gives_back(s2);  // s2는 takes_and_gives_back 안으로
                                        // 이동되었고, 이 함수가 반환값을 s3으로도
                                        // 이동시켰습니다.

} // 여기서 s3는 스코프 밖으로 벗어났으며 drop이 호출됩니다. s2는 스코프 밖으로
  // 벗어났지만 이동되었으므로 아무 일도 일어나지 않습니다. s1은 스코프 밖으로
  // 벗어나서 drop이 호출됩니다.

fn gives_ownership() -> String {             // gives_ownership 함수가 반환 값을
                                             // 호출한 쪽으로 이동시킵니다.

    let some_string = String::from("hello"); // some_string이 스코프 안에 들어왔습니다.

    some_string                              // some_string이 반환되고, 호출한 쪽의
                                             // 함수로 이동됩니다.
}

// takes_and_gives_back 함수는 String을 하나 받아서 다른 하나를 반환합니다.
fn takes_and_gives_back(a_string: String) -> String { // a_string이 스코프
                                                      // 안으로 들어왔습니다.

    a_string  // a_string은 반환되고, 호출한 쪽의 함수로 이동됩니다.
}
```

변수의 소유권은 모든 순간 똑같은 패턴을 따릅니다: 어떤 값을 다른 변수에 대입하면
값이 이동됩니다. 힙에 데이터를 갖고 있는 변수가 스코프 밖으로 벗어나면, 해당 값은
데이터가 다른 변수에 의해 소유되도록 이동하지 않는한 `drop`에 의해 제거될 것입니다.

모든 함수가 소유권을 가졌다가 반납하는 것은 조금 지루해 보입니다.
만일 함수에게 값을 사용할 수 있도록 하되 소유권은 갖지 않도록 하고 싶다면요?
함수의 본체로부터 얻어진 결과와 더불어 우리가 넘겨주고자 하는 어떤 값을 다시 쓰고 싶어서
함께 반환받아야 한다면 꽤나 짜증나겠지요. 

이게 아래와 같이 튜플을 이용하여 여러 값을 돌려받는 식으로 가능하긴 합니다:

<span class="filename">Filename: src/main.rs</span>

```rust
fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("The length of '{}' is {}.", s2, len);
}

fn calculate_length(s: String) -> (String, usize) {
    let length = s.len(); // len()함수는 문자열의 길이를 반환합니다.

    (s, length)
}
```

하지만 이건 너무 많이 나간 의례절차고 일반적인 개념로서는 과한 작업이 됩니다.
운좋게도, 러스트는 이를 위한 기능을 갖고 있으며, *참조자*(*references*)라고 부릅니다.
